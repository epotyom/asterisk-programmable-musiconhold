

set("log.file.path","/tmp/liquidsoap-79500996294.log")
set("log.level", 4)
set("server.socket",true)
set("server.socket.path","/tmp/testliq.sock")
	
iMusic = interactive.string("music","music0")
	
		sMusic0 = single("/usr/scripts/liquidsoap/music/mono-8000.wav")
		
		sMusic1 = single("/usr/scripts/liquidsoap/music/mono2-8000.wav")
		
		sMusic2 = single("/usr/scripts/liquidsoap/music/mono3-8000.wav")
		
	# By default advices randomized before play in playlist
	##sAdvices = playlist("/usr/scripts/liquidsoap/music/advices/")
		
	lSwitchSayBalance = ref false
	iSwitchSaybalance = interactive.bool("switchsaybalance",false)
	def checkSaybalance() =
		if !lSwitchSayBalance != iSwitchSaybalance() then
			lSwitchSayBalance := iSwitchSaybalance()
			true
		else
			false
		end	
	end
	sBalance = playlist.merge("/var/run/asterisk/79500996294-balanceplaylist.txt")
	
	lSwitchSayPosition = ref false
	iSwitchSayPosition = interactive.bool("switchsayposition",false)
	iQueuePosition = interactive.string("queueposition","0")
	def fSayPosition() =
		# file must be generated by python before call it here
		#if iQueuePosition() != "0" then
			request.destroy()
			request.create("/tmp/say/position"^iQueuePosition()^".mp3")
		#else
		#	request.create("/tmp/say/positionNotExist.mp3")
		#end
			
	end	
	def checkSayposition() =
		if !lSwitchSayPosition != iSwitchSayPosition() then
			lSwitchSayPosition := iSwitchSayPosition()
			true
		else
			false
		end	
	end
	
	sResult = mksafe(
		switch(track_sensitive=false,
		#transitions=[cross],
		[
	
				({"music0" == iMusic()},sMusic0),
		
				({"music1" == iMusic()},sMusic1),
		
				({"music2" == iMusic()},sMusic2),
		
		])
	)
	
	# delay advices
	##sDelayedAdvices = once(delay(20.,sAdvices))

	# say balance or position if requested
	sResult = add([sResult, switch([
		(checkSaybalance, sBalance),
		(checkSayposition, request.dynamic(fSayPosition)),
		##({ not checkSaybalance() }, sDelayedAdvices),		
	])],weights=[1,10])
	

	##### Output wav to stdout#####
	# clock must be in sync=true so there is no output buffer
	# clock.assign_new(sync=false,[sResult])
	# flush=true makes it send data as soon as possible, not 64k every 5 sec (makes no delay before start)
	out = output.file(%wav(header=true, channels=1, samplerate=8000), "/dev/stdout", sResult, flush=true)
	
